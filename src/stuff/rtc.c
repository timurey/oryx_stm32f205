/**
 *****************************************************************************
 * @title   RTC_Timer.c
 * @author  CooCox
 * @date    12 Nov 2013
 * @brief   This example demonstrates and explains how to use the RTC periph
 *          eral. As an application example, it demonstrates how to setup th
 *          e RTC peripheral, in terms of prescaler and interrupts, to be us
 *          ed to keep time and to generate Second interrupt.After downloadi
 *          ng, you need configure the RTC. then the RTC Timer will display
 *          on the UART. the LED which connected to PB8 will toggles every 1
 *           s. Please retarget The C library printf function to the  USART1
 *           at PrintChar function in printf.c. This example has been tested
 *           on KEIL MCBSTM32 board, STM32F103RBT6 device. Before downloadin
 *          g executable file into Evaluation Board, make sure that an RS-23
 *          2 cable has been connected between PC and development board, the
 *          n run it.
 *******************************************************************************
 */
////// The above comment is automatically generated by CoIDE ///////////////////

/**
 ******************************************************************************
 * @file    RTC/RTC_Timer/main.c
 * @author  MCD Application Team
 * @version V1.0.0
 * @date    30-October-2010
 * @brief   Main program body
 ******************************************************************************
 * @attention
 *
 * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
 * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
 * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
 * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
 * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
 * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
 *
 * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
 ******************************************************************************
 */

/* Includes ------------------------------------------------------------------*/
#include "build_time.h"
#include "rtc.h"
#include <time.h>
#include "date_time.h"

/***************************************************************************//**
 * Global variables, private define and typedef
 ******************************************************************************/
//#define RTCClockOutput_Enable  /* RTC Clock/64 is output on tamper pin(PC.13) */

/***************************************************************************//**
 * Declare function prototypes
 ******************************************************************************/
//static void NVIC_Configuration(void);
#define RTC_ASYNCH_PREDIV  0x7F   /* LSE as RTC clock */
#define RTC_SYNCH_PREDIV   0x00FF /* LSE as RTC clock */

time_t timezone = 5*60*60;
RTC_HandleTypeDef RtcHandle;


/**
 * @brief  The Low Speed External (LSE) clock is used as RTC clock source.
 * The RTC clock can be output on the Tamper pin (PC.13). To enable this functionality,
 * uncomment the corresponding line: #define RTCClockOutput_Enable.
 * The RTC is in the backup (BKP) domain, still powered by VBAT when VDD is switched off,
 * so the RTC configuration is not lost if a battery is connected to the VBAT pin.
 * A key value is written in backup data register1 (BKP_DR1) to indicate if the RTC
 * is already configured.
 * @param  None
 * @retval None
 */
static void Error_Handler(void)
{
  while (1)
  {
  }
}

void RTC_Init(void)
{

	/*##-1- Configure the RTC peripheral #######################################*/
	/* Configure RTC prescaler and RTC data registers */
	/* RTC configured as follow:
	      - Hour Format    = Format 24
	      - Asynch Prediv  = Value according to source clock
	      - Synch Prediv   = Value according to source clock
	      - OutPut         = Output Disable
	      - OutPutPolarity = High Polarity
	      - OutPutType     = Open Drain */
	RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24;
	RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV;
	RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV;
	RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE;
	RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
	RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
	RtcHandle.Instance = RTC;

	if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
	{
		/* Initialization Error */
			    Error_Handler();
	}

	/*##-2- Check if Data stored in BackUp register0: No Need to reconfigure RTC#*/
	/* Read the Back Up Register 0 Data */
	if (HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR0) != 0x32F2)
	{
		/* Configure RTC Calendar */
		RTC_CalendarConfig(____TIMESTAMP____);
	}
	else
	{
		/* Check if the Power On Reset flag is set */
		if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) != RESET)
		{
			/* Turn on LED2: Power on reset occured */
		}
		/* Check if Pin Reset flag is set */
		if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
		{
			/* Turn on LED4: External reset occured */
		}
		/* Clear source Reset Flag */
		__HAL_RCC_CLEAR_RESET_FLAGS();
	}

}

/**
 * @brief  This function handles RTC global interrupt request.
 * @param  None
 * @retval None
 */
//void RTC_IRQHandler(void)
//{
	//	if (RTC_GetITStatus(RTC_IT_SEC) != RESET) //Ежесекундное прерывание
	//	{
	//		/* Clear the RTC Second interrupt */
	//		RTC_ClearITPendingBit(RTC_IT_SEC);
	//
	//		/* Wait until last write operation on RTC registers has finished */
	//		RTC_WaitForLastTask();
	//	}
//}

/**
 * @brief  Configure the current time and date.
 * @param  None
 * @retval None
 */

void RTC_CalendarConfig(time_t unixtime)
{
	DateTime date;
	RTC_DateTypeDef sdatestructure;
	RTC_TimeTypeDef stimestructure;

	convertUnixTimeToDate(unixtime, &date);

	/*##-1- Configure the Date #################################################*/
	/* Set Date: Tuesday February 18th 2014 */
	sdatestructure.Year = (uint8_t)(date.year - 2000);
	sdatestructure.Month = date.month;
	sdatestructure.Date = date.day;
	sdatestructure.WeekDay = date.dayOfWeek;

	if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,FORMAT_BIN) != HAL_OK)
	{
		/* Initialization Error */
		Error_Handler();
	}

	/*##-2- Configure the Time #################################################*/
	/* Set Time: 02:00:00 */
	stimestructure.Hours = date.hours;
	stimestructure.Minutes = date.minutes;
	stimestructure.Seconds = date.seconds;
	stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
	stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
	stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;

	if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, FORMAT_BIN) != HAL_OK)
	{
		/* Initialization Error */
		Error_Handler();
	}

	/*##-3- Writes a data in a RTC Backup data Register0 #######################*/
	HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR0, 0x32F2);
}

void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc)
{
  RCC_OscInitTypeDef        RCC_OscInitStruct;
  RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;
  (void ) hrtc;
  /*##-1- Enables the PWR Clock and Enables access to the backup domain ###################################*/
  /* To change the source clock of the RTC feature (LSE, LSI), You have to:
     - Enable the power clock using __PWR_CLK_ENABLE()
     - Enable write access using HAL_PWR_EnableBkUpAccess() function before to
       configure the RTC clock source (to be done once after reset).
     - Reset the Back up Domain using __HAL_RCC_BACKUPRESET_FORCE() and
       __HAL_RCC_BACKUPRESET_RELEASE().
     - Configure the needed RTc clock source */
  __PWR_CLK_ENABLE();
  HAL_PWR_EnableBkUpAccess();

  /*##-2- Configue LSE as RTC clock soucre ###################################*/
  RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.LSIState = RCC_LSI_OFF;
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
  if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /*##-3- Enable RTC peripheral Clocks #######################################*/
  /* Enable RTC Clock */
  __HAL_RCC_RTC_ENABLE();
}

/**
  * @brief RTC MSP De-Initialization
  *        This function frees the hardware resources used in this example:
  *          - Disable the Peripheral's clock
  * @param hrtc: RTC handle pointer
  * @retval None
  */
void HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc)
{
	(void ) hrtc;
  /*##-1- Reset peripherals ##################################################*/
  __HAL_RCC_RTC_DISABLE();

  /*##-2- Disables the PWR Clock and Disables access to the backup domain ###################################*/
  HAL_PWR_DisableBkUpAccess();
  __PWR_CLK_DISABLE();
}

